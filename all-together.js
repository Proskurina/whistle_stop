

// Generated by CoffeeScript 1.10.0
(function() {
  var _Audio,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _Audio = (function() {
    var _audioContext, _defaultOptions, _errorCallbacks, _startCallbacks, _updateCallbacks;

    _audioContext = window.AudioContext || window.webkitAudioContext;

    _startCallbacks = [];

    _updateCallbacks = [];

    _errorCallbacks = [];

    _defaultOptions = {
      alpha: 0.5,
      sampleSize: 2048,
      spectrumStart: 18,
      spectrumRange: 38
    };

    function _Audio(opts) {
      var i, key, val;
      if (opts == null) {
        opts = {};
      }
      this.startRecording = bind(this.startRecording, this);
      this.setupStream = bind(this.setupStream, this);
      this.analyse = bind(this.analyse, this);
      if (!_audioContext) {
        return;
      }
      this.context = new _audioContext();
      this.options = _defaultOptions;
      for (key in opts) {
        val = opts[key];
        this.options[key] = val;
      }
      this.buffer = new Uint8Array(this.options.sampleSize / 2);
      this.fft = new FFT(this.options.sampleSize / 2, this.context.sampleRate);
      this.spectrum = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = this.options.spectrumRange; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
          results.push(0);
        }
        return results;
      }).call(this);
      this.stats = {};
    }

    _Audio.prototype.analyse = function() {
      var fn, i, j, k, len, mag, newBinVal, opts, ref, results, s;
      window.requestAnimationFrame(this.analyse);
      this.analyser.getByteTimeDomainData(this.buffer);
      this.fft.forward(this.buffer);
      s = this.stats;
      s.maxBinFreq = 0;
      s.maxBinVal = 0;
      s.totalVal = 0;
      opts = this.options;
      for (i = j = 0, ref = opts.spectrumRange; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        mag = this.fft.spectrum[i + opts.spectrumStart];
        newBinVal = (1.0 - opts.alpha) * +mag * opts.alpha;
        if (newBinVal > s.maxBinVal) {
          s.maxBinFreq = this.frequencyFromBin(i + opts.spectrumStart);
          s.maxBinVal = newBinVal;
        }
        s.totalVal += newBinVal;
        this.spectrum[i] = newBinVal;
      }
      results = [];
      for (k = 0, len = _updateCallbacks.length; k < len; k++) {
        fn = _updateCallbacks[k];
        results.push(fn(this));
      }
      return results;
    };

    _Audio.prototype.setupStream = function(stream) {
      var fn, j, len;
      this.stream = this.context.createMediaStreamSource(stream);
      this.analyser = this.context.createAnalyser();
      this.analyser.fftSize = 2048;
      this.stream.connect(this.analyser);
      for (j = 0, len = _startCallbacks.length; j < len; j++) {
        fn = _startCallbacks[j];
        fn();
      }
      return this.analyse();
    };

    _Audio.prototype.onError = function(fn) {
      return _errorCallbacks.push(fn);
    };

    _Audio.prototype.onStart = function(fn) {
      return _startCallbacks.push(fn);
    };

    _Audio.prototype.onUpdate = function(fn) {
      return _updateCallbacks.push(fn);
    };

    _Audio.prototype.startRecording = function() {
      if (!this.context) {
        return;
      }
      return this.getUserMedia({
        audio: true
      }, this.setupStream);
    };

    _Audio.prototype.getUserMedia = function(dictionary, callback) {
      var e, error;
      try {
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        return navigator.getUserMedia(dictionary, callback, function() {
          var fn, j, len, results;
          results = [];
          for (j = 0, len = _errorCallbacks.length; j < len; j++) {
            fn = _errorCallbacks[j];
            results.push(fn());
          }
          return results;
        });
      } catch (error) {
        e = error;
        return typeof this.onError === "function" ? this.onError('getUserMedia threw exception :' + e) : void 0;
      }
    };

    _Audio.prototype.centFromFrequency = function(f) {
      var noteNum;
      if (f == null) {
        f = 0;
      }
      if (f === 0) {
        return 0;
      }
      noteNum = 12 * (Math.log(f / 440) / Math.log(2));
      return Math.round(noteNum * 10) + 690;
    };

    _Audio.prototype.frequencyFromBin = function(b) {
      return b * this.context.sampleRate / this.options.sampleSize;
    };

    return _Audio;

  })();

  window.Audio = new _Audio;

}).call(this);

/*
 *  DSP.js - a comprehensive digital signal processing  library for javascript
 *
 *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.
 *  Copyright 2010 Corban Brook. All rights reserved.
 *
 */

// Fourier Transform Module used by DFT, FFT, RFFT
function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth  = 2 / bufferSize * sampleRate / 2;

  this.spectrum   = new Float32Array(bufferSize/2);
  this.real       = new Float32Array(bufferSize);
  this.imag       = new Float32Array(bufferSize);

  this.peakBand   = 0;
  this.peak       = 0;

  /**
   * Calculates the *middle* frequency of an FFT band.
   *
   * @param {Number} index The index of the FFT band.
   *
   * @returns The middle frequency in Hz.
   */
  this.getBandFrequency = function(index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function() {
    var spectrum  = this.spectrum,
        real      = this.real,
        imag      = this.imag,
        bSi       = 2 / this.bufferSize,
        sqrt      = Math.sqrt,
        rval,
        ival,
        mag;

    for (var i = 0, N = bufferSize/2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = bSi * sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

/**
 * FFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.reverseTable = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI/i);
    this.cosTable[i] = Math.cos(-Math.PI/i);
  }
}

/**
 * Performs a forward transform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
 *
 * @returns The frequency spectrum array
 */
FFT.prototype.forward = function(buffer) {
  // Locally scope variables for speed up
  var bufferSize      = this.bufferSize,
      cosTable        = this.cosTable,
      sinTable        = this.sinTable,
      reverseTable    = this.reverseTable,
      real            = this.real,
      imag            = this.imag,
      spectrum        = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);

  if (Math.pow(2, k) !== bufferSize) { throw "Invalid buffer size, must be a power of 2."; }
  if (bufferSize !== buffer.length)  { throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length; }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);
    //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];

    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);
        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);
      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);
    }

    halfSize = halfSize << 1;
  }

  return this.calculateSpectrum();
};

// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.NoteRecorder = (function() {
    var _defaultOptions, _idleCallbacks, _updateCallbacks;

    _updateCallbacks = [];

    _idleCallbacks = [];

    _defaultOptions = {
      tolerance: 10,
      minDuration: 20,
      idleTimeout: 40
    };

    function NoteRecorder(audio, opts) {
      var key, val;
      if (opts == null) {
        opts = {};
      }
      this.analyse = bind(this.analyse, this);
      audio.onUpdate(this.analyse);
      this.options = _defaultOptions;
      for (key in opts) {
        val = opts[key];
        this.options[key] = val;
      }
      this.lastNote = 0;
      this.pitchDuration = 0;
      this.reset();
    }

    NoteRecorder.prototype.analyse = function(audio) {
      var fn, j, k, len, len1, note, o;
      o = this.options;
      note = audio.centFromFrequency(audio.stats.maxBinFreq);
      if (note >= this.lastNote - o.tolerance && note <= this.lastNote + o.tolerance) {
        this.pitchDuration++;
      } else {
        if (this.pitchDuration > o.minDuration) {
          this.sequence.push(this.lastNote);
          this.idleDuration = 0;
          for (j = 0, len = _updateCallbacks.length; j < len; j++) {
            fn = _updateCallbacks[j];
            fn();
          }
        } else {
          this.idleDuration++;
        }
        this.lastNote = 0;
        this.pitchDuration = 0;
      }
      if (this.idleDuration > o.idleTimeout) {
        for (k = 0, len1 = _idleCallbacks.length; k < len1; k++) {
          fn = _idleCallbacks[k];
          fn();
        }
        this.reset();
      }
      return this.lastNote = note;
    };

    NoteRecorder.prototype.onIdle = function(fn) {
      return _idleCallbacks.push(fn);
    };

    NoteRecorder.prototype.onUpdate = function(fn) {
      return _updateCallbacks.push(fn);
    };

    NoteRecorder.prototype.sequenceDeltas = function() {
      var el, i, j, len, ref, results;
      ref = this.sequence;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        el = ref[i];
        results.push(el - this.sequence[0]);
      }
      return results;
    };

    NoteRecorder.prototype.reset = function() {
      this.idleDuration = 0;
      return this.sequence = [];
    };

    return NoteRecorder;

  })();

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  window.totalPoints = 300;

  window.Data = new Array(totalPoints);

  window.idx = 0;

  window.addToPlotData = function(point) {
    var d;
    d = window.Data;
    d[window.idx++] = [window.idx, point];
    if (window.idx >= totalPoints) {
      return window.idx = 0;
    }
  };

  $(function() {
    var data, getRandomData, plot, totalPoints, update, updateInterval;
    return;
    data = [];
    getRandomData = function() {
      var i, prev, res, y;
      if (data.length > 0) {
        data = data.slice(1);
      }
      while (data.length < totalPoints) {
        prev = (data.length > 0 ? data[data.length - 1] : 50);
        y = prev + Math.random() * 10 - 5;
        if (y < 0) {
          y = 0;
        } else {
          if (y > 100) {
            y = 100;
          }
        }
        data.push(y);
      }
      res = [];
      i = 0;
      while (i < data.length) {
        res.push([i, data[i]]);
        ++i;
      }
      return res;
    };
    update = function() {
      plot.setData([window.Data]);
      plot.draw();
      return setTimeout(update, updateInterval);
    };
    data = [];
    totalPoints = 300;
    updateInterval = 30;
    $("#updateInterval").val(updateInterval).change(function() {
      var v;
      v = $(this).val();
      if (v && !isNaN(+v)) {
        updateInterval = +v;
        if (updateInterval < 1) {
          updateInterval = 1;
        } else {
          if (updateInterval > 2000) {
            updateInterval = 2000;
          }
        }
        return $(this).val("" + updateInterval);
      }
    });
    plot = $.plot("#placeholder", [getRandomData()], {
      series: {
        shadowSize: 0
      },
      yaxis: {
        min: 600,
        max: 880,
        logarithmicScale: false
      },
      xaxis: {
        show: false
      }
    });
    return update();
  });

}).call(this);


// Generated by CoffeeScript 1.10.0
(function() {
  var LOGGED_IN, arrayEquals, cHeight, cWidth, canvas, ctx, currentClass, currentSequence, inClass, nr, outClass, setLoginState, setPasswordField;

  if (window.chrome == null) {
    alert('Sorry, this login method only works in Chrome due to HTML5 audio issues');
  }

  $(Audio.startRecording);

  window.Users = [
    {
      name: 'Sebastian Wallin',
      image: 'https://secure.gravatar.com/avatar/46ab5c60ced85b09c35fd31a510206ef?s=192',
      sequence: [0, -40, -26, -85]
    }, {
      name: 'Johan Brissmyr',
      image: 'http://www.gravatar.com/avatar/6b7b3a9f9d1c63a344cfc1d8ebb02981?s=192',
      sequence: [0]
    }
  ];

  arrayEquals = function(arr, arr2, tolerance) {
    var el, i, j, len;
    if (tolerance == null) {
      tolerance = 15;
    }
    if (arr.length !== arr2.length) {
      return false;
    }
    for (i = j = 0, len = arr2.length; j < len; i = ++j) {
      el = arr2[i];
      if (el < (arr[i] - tolerance) || el > (arr[i] + tolerance)) {
        return false;
      }
    }
    return true;
  };

  outClass = 'pt-page-rotateBottomSideFirst';

  inClass = 'pt-page-moveFromBottom pt-page-delay200 pt-page-ontop';

  currentClass = 'pt-page-current';

  LOGGED_IN = false;

  setLoginState = function(user) {
    var $el, cls, currPage, nextPage;
    if (LOGGED_IN === !!user) {
      return;
    }
    LOGGED_IN = !!user;
    $el = $('#pt-main');
    cls = !user ? '.login' : '.logout';
    currPage = $el.find('.' + currentClass).addClass(outClass);
    nextPage = $el.find(cls).addClass(inClass).addClass(currentClass);
    setTimeout(function() {
      currPage.removeClass(currentClass).removeClass(outClass);
      return nextPage.removeClass(inClass);
    }, 800);
    $el.find('#name').text(user != null ? user.name : void 0);
    $el.find('#avatar').attr('src', (user != null ? user.image : void 0) || '');
  };

  setPasswordField = function(sequence) {
    var html, s;
    html = ((function() {
      var j, len, results;
      results = [];
      for (j = 0, len = sequence.length; j < len; j++) {
        s = sequence[j];
        results.push("<li>&#9679;</li>");
      }
      return results;
    })()).join('');
    return $('#password').html(html);
  };

  currentSequence = [];

  window.Authentication = {
    setPassword: function(sequence) {
      currentSequence = sequence;
      return setPasswordField(sequence);
    },
    login: function(sequence) {
      var j, len, user;
      if (sequence) {
        Authentication.setPassword(sequence);
      }
      for (j = 0, len = Users.length; j < len; j++) {
        user = Users[j];
        if (arrayEquals(currentSequence, user.sequence)) {
          console.log("success");
          chrome.runtime.sendMessage({shutdown: true}, function(){});
          setLoginState(user);
        }
      }
    },
    logout: function() {
      setLoginState(null);
    }
  };

  // canvas = document.getElementById('fft');

  // ctx = canvas.getContext('2d');

  // ctx.fillStyle = "rgba(0, 0, 0, 0.2)";

  // cHeight = canvas.height;

  // cWidth = canvas.width;

  Audio.onStart(function() {
    return $('.trigger-pulse').addClass('pulsate');
  });

  Audio.onError(function() {
    return alert("There was a problem accessing the audio.\nPlease check permissions.");
  });

  Audio.onUpdate(function() {
    var i, j, len, ref, results, spacing, val;
    spacing = cWidth / Audio.options.spectrumRange;
    // ctx.clearRect(0, 0, cWidth, cHeight);
    ref = Audio.spectrum;
    results = [];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      val = ref[i];
      // results.push(ctx.fillRect(i * spacing, cHeight, spacing / 1.5, -val * 200));
    }
    return results;
  });

  nr = new NoteRecorder(Audio);

  nr.onUpdate(function() {
    return Authentication.setPassword(nr.sequenceDeltas(nr.sequence));
  });

  nr.onIdle(function() {
    Authentication.login();
    return Authentication.setPassword([]);
  });

}).call(this);
